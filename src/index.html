---
permalink: /index.html
---

<!DOCTYPE html>
<html>
  <head>
    <base href="." />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neomania</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="Neomania" />
    <meta name="description" content="Neomania Podcast" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://neomania.net/" />
    <meta property="og:title" content="Neomania" />
    <meta property="og:description" content="Neomania Podcast" />
    <meta
      property="og:image"
      content="https://neomania.net/images/neomania-preview.png"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://neomania.net/" />
    <meta property="twitter:title" content="Neomania" />
    <meta property="twitter:description" content="Neomania Podcast" />
    <meta
      property="twitter:image"
      content="https://neomania.net/images/neomania-preview.png"
    />
    <meta property="twitter:creator" content="@robotson" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,slnt,wdth,wght,GRAD,XOPQ,XTRA,YOPQ,YTAS,YTDE,YTFI,YTLC,YTUC@8..144,-10..0,25..151,100..1000,-200..150,27..175,323..603,25..135,649..854,-305..-98,560..788,416..570,528..760&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/css/themes.css?v=1.0" />

    <style>
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: var(--bg-color);
        color: var(--text-color);
        overflow: hidden;
        padding: 1rem;
        box-sizing: border-box;
        position: relative;
      }

      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 0;
        pointer-events: none;
        opacity: 0.6;
      }

      .container {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 1200px;
        position: relative;
        z-index: 1;
      }

      .text {
        font-family: "Roboto Flex";
        font-size: 12vw;
        text-align: center;
        margin-bottom: 1rem;
        width: 100%;
        white-space: nowrap;
      }

      .text span {
        display: inline-block;
        font-variation-settings: "wght" 400, "wdth" 100, "opsz" 48, "GRAD" 0,
          "slnt" 0, "XOPQ" 100, "XTRA" 468, "YOPQ" 79, "YTAS" 750, "YTDE" -203,
          "YTFI" 738, "YTLC" 514, "YTUC" 712;
        text-shadow: var(--text-shadow);
      }

      .subtitle {
        font-family: "Roboto Flex";
        font-size: 1.2rem;
        text-align: center;
        margin-bottom: 2rem;
        opacity: 0.8;
        max-width: 600px;
      }

      .letter {
        display: inline-block;
        font-variation-settings: "wght" 400, "wdth" 100, "opsz" 48, "GRAD" 0,
          "slnt" 0, "XOPQ" 100, "XTRA" 468, "YOPQ" 79, "YTAS" 750, "YTDE" -203,
          "YTFI" 738, "YTLC" 514, "YTUC" 712;
        text-shadow: var(--text-shadow);
      }

      .listen-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 0;
        margin-top: 1.5rem;
      }

      .listen-heading {
        font-family: "Roboto Flex";
        font-size: 1.1rem;
        margin-bottom: 1rem;
        font-weight: 500;
        opacity: 0.9;
      }

      .podcast-platforms {
        display: flex;
        justify-content: center;
        gap: 1.5rem;
        flex-wrap: wrap;
        margin-bottom: 1rem;
        position: relative;
      }

      .platform-link {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.4rem;
        text-decoration: none;
        color: var(--text-color);
        transition: all 0.3s ease;
        opacity: 0.8;
        width: 60px;
        height: 75px;
        justify-content: space-between;
      }

      .platform-link:hover {
        opacity: 1;
      }

      .platform-icon {
        width: 38px;
        height: 38px;
        transition: all 0.3s ease;
        object-fit: contain;
        background-color: transparent;
        padding: 3px;
        display: flex;
        justify-content: center;
        align-items: center;
        filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        margin-left: auto;
        margin-right: auto;
      }

      .platform-link:hover .platform-icon {
        transform: scale(1.05);
        filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.15));
      }

      .platform-link:hover .icon-wrapper {
        transform: scale(1.05);
      }

      /* Theme-specific icon visibility */
      .dark-only {
        display: none;
      }

      .light-only {
        display: none;
      }

      /* Default state (dark mode) */
      .apple-colored,
      .spotify-colored,
      .rss-colored {
        display: flex;
      }

      /* Light mode */
      html.light-theme .dark-only {
        display: none;
      }

      html.light-theme .light-only {
        display: flex;
      }

      html.light-theme .apple-colored,
      html.light-theme .spotify-colored,
      html.light-theme .rss-colored {
        display: none;
      }

      /* Dark mode */
      html:not(.light-theme) .light-only {
        display: none;
      }

      html:not(.light-theme) .dark-only {
        display: flex;
      }

      html:not(.light-theme) .apple-colored,
      html:not(.light-theme) .spotify-colored,
      html:not(.light-theme) .rss-colored {
        display: none;
      }

      .platform-name {
        font-family: "Roboto Flex";
        font-size: 0.85rem;
        text-align: center;
        font-weight: 400;
        margin-top: auto;
        padding-top: 0.25rem;
      }

      .links {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 1.5rem;
        font-family: "Roboto Flex";
        font-size: 1rem;
        margin-top: 1rem;
        width: auto;
        opacity: 0.75;
        position: relative;
        padding-top: 1.25rem;
      }

      .links:before {
        content: "";
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 100px;
        height: 1px;
        background-color: var(--text-color);
        opacity: 0.25;
      }

      .links a {
        color: var(--text-color);
        text-decoration: none;
        padding: 0.5rem;
        transition: all 0.3s ease;
        text-shadow: none;
        text-align: center;
        border: none;
      }

      .links a:hover {
        opacity: 1;
        transform: none;
        text-decoration: underline;
        background-color: transparent;
      }

      .email-protection {
        cursor: pointer;
      }

      /* Toast notification for email copy instead of alert */
      .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--bg-color);
        color: var(--text-color);
        padding: 12px 24px;
        border-radius: 4px;
        font-family: "Roboto Flex";
        font-size: 1rem;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
        z-index: 1000;
        text-align: center;
        max-width: 90%;
        border: 1px solid var(--border-color);
      }

      .toast.show {
        opacity: 1;
      }

      /* Media queries for better responsiveness */
      @media (max-width: 600px) {
        .text {
          font-size: 14vw;
        }

        .links,
        .podcast-platforms {
          gap: 1rem;
        }

        .platform-icon {
          width: 34px;
          height: 34px;
          padding: 2px;
        }

        .platform-link {
          height: 80px;
        }

        .spotify-colored,
        .spotify-white,
        .spotify-black {
          width: 65px;
          height: 26px;
          margin-bottom: 3px;
        }
      }

      @media (min-width: 1200px) {
        .text {
          font-size: 100px;
        }
      }

      .sun-beams line {
        stroke: var(--text-color);
        stroke-width: 2px;
        transform-origin: center;
      }

      /* Platform-specific icon styles */
      .spotify-colored,
      .spotify-white,
      .spotify-black {
        width: 40px;
        height: 40px;
        object-fit: scale-down;
        max-width: 100%;
        padding: 0;
      }

      .platform-icon:not(.spotify-colored):not(.spotify-white):not(
          .spotify-black
        ) {
        width: 40px;
        height: 40px;
      }

      /* Create a centered icon wrapper for consistent positioning */
      .icon-wrapper {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        flex-grow: 1;
        height: 40px;
        margin-bottom: 0.25rem;
      }

      /* Copy feedback styles */
      .copied-text {
        display: none;
        font-weight: 500;
      }

      .copied .copy-text {
        display: none;
      }

      .copied .copied-text {
        display: block;
      }

      /* RSS link hover effect */
      #copy-rss-link {
        cursor: pointer;
      }

      #copy-rss-link:hover .copy-text {
        text-decoration: underline;
      }

      /* Motion-related settings */
      html[data-motion="reduced"] .theme-toggle {
        transition: none;
      }
    </style>
  </head>
  <body>
    <canvas id="noise-canvas"></canvas>

    <button class="theme-toggle" aria-label="Toggle theme">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        aria-hidden="true"
        viewBox="0 0 24 24"
        width="24"
        height="24"
      >
        <!-- Sun circle -->
        <circle class="sun" cx="12" cy="12" r="5" />

        <!-- Moon shape -->
        <path
          class="moon"
          d="M12 3a9 9 0 1 0 9 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 0 1-4.4 2.26 5.403 5.403 0 0 1-3.14-9.8c-.44-.06-.9-.1-1.36-.1z"
        />

        <!-- Sun rays -->
        <g class="sun-beams">
          <line x1="12" y1="1" x2="12" y2="3" />
          <line x1="12" y1="21" x2="12" y2="23" />
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
          <line x1="1" y1="12" x2="3" y2="12" />
          <line x1="21" y1="12" x2="23" y2="12" />
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
        </g>
      </svg>
    </button>

    <div class="container">
      <h1 class="text">
        <span class="n">N</span>
        <span class="e">e</span>
        <span class="o">o</span>
        <span class="m">m</span>
        <span class="a">a</span>
        <span class="n2">n</span>
        <span class="i">i</span>
        <span class="a2">a</span>
      </h1>

      <div class="listen-section">
        <h2 class="listen-heading">Listen on your favorite platform</h2>
        <div class="podcast-platforms">
          <a
            href="https://podcasts.apple.com/us/podcast/neomania/id1790739651"
            target="_blank"
            class="platform-link"
            aria-label="Listen on Apple Podcasts"
          >
            <div class="icon-wrapper">
              <img
                src="/images/podcast-icons/Apple_Podcasts_Icon_RGB_sm_060623.svg"
                alt="Apple Podcasts"
                class="platform-icon apple-colored"
              />
              <img
                src="/images/podcast-icons/Apple_Podcasts_Icon_wht_sm_060623.svg"
                alt="Apple Podcasts"
                class="platform-icon apple-white dark-only"
              />
              <img
                src="/images/podcast-icons/Apple_Podcasts_Icon_blk_sm_060623.svg"
                alt="Apple Podcasts"
                class="platform-icon apple-black light-only"
              />
            </div>
            <span class="platform-name">Apple</span>
          </a>
          <a
            href="https://open.spotify.com/show/5W84onjnHfTqz1Sg0ndqsA"
            target="_blank"
            class="platform-link"
            aria-label="Listen on Spotify"
          >
            <div class="icon-wrapper">
              <img
                src="/images/podcast-icons/Spotify_Primary_Logo_RGB_Green.png"
                alt="Spotify"
                class="platform-icon spotify-colored"
              />
              <img
                src="/images/podcast-icons/Spotify_Primary_Logo_RGB_White.png"
                alt="Spotify"
                class="platform-icon spotify-white dark-only"
              />
              <img
                src="/images/podcast-icons/Spotify_Primary_Logo_RGB_Black.png"
                alt="Spotify"
                class="platform-icon spotify-black light-only"
              />
            </div>
            <span class="platform-name">Spotify</span>
          </a>
          <a
            href="https://anchor.fm/s/ffb36578/podcast/rss"
            class="platform-link"
            id="copy-rss-link"
            aria-label="Copy RSS Feed URL"
            onclick="event.preventDefault(); navigator.clipboard.writeText('https://anchor.fm/s/ffb36578/podcast/rss'); this.classList.add('copied'); setTimeout(() => this.classList.remove('copied'), 2000);"
          >
            <div class="icon-wrapper">
              <img
                src="/images/podcast-icons/rss_simple_black.svg"
                alt="RSS Feed"
                class="platform-icon rss-colored"
              />
              <img
                src="/images/podcast-icons/rss_simple_white.svg"
                alt="RSS Feed"
                class="platform-icon rss-white dark-only"
              />
              <img
                src="/images/podcast-icons/rss_simple_black.svg"
                alt="RSS Feed"
                class="platform-icon rss-black light-only"
              />
            </div>
            <span class="platform-name copy-text">Copy RSS</span>
            <span class="platform-name copied-text">Copied!</span>
          </a>
        </div>
      </div>

      <div class="links">
        <a href="https://twitter.com/robotson" target="_blank">Twitter</a>
        <a href="#" class="email-protection" id="email-link">Contact</a>
      </div>

      <!-- Toast notification element for email copy -->
      <div id="toast" class="toast">
        Email copied to clipboard: contact [at] neomania [dot] net
      </div>
    </div>

    <script>
      // Theme toggle functionality
      const themeToggle = document.querySelector(".theme-toggle");

      // Set data-motion attribute
      document.documentElement.setAttribute("data-motion", "normal");
      let isReducedMotion = false;

      // Check for prefers-reduced-motion
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
        document.documentElement.setAttribute("data-motion", "reduced");
        isReducedMotion = true;
      }

      // Check saved theme preference or system preference
      const savedTheme = localStorage.getItem("theme");
      if (savedTheme) {
        if (savedTheme === "light") {
          document.documentElement.classList.add("light-theme");
        }
      } else {
        // Check system preference on first load
        if (window.matchMedia("(prefers-color-scheme: light)").matches) {
          document.documentElement.classList.add("light-theme");
          localStorage.setItem("theme", "light");
        }
      }

      // Listen for system theme changes
      window
        .matchMedia("(prefers-color-scheme: light)")
        .addEventListener("change", (e) => {
          if (!localStorage.getItem("theme")) {
            // Only react if user hasn't set a preference
            if (e.matches) {
              document.documentElement.classList.add("light-theme");
            } else {
              document.documentElement.classList.remove("light-theme");
            }
          }
        });

      themeToggle.addEventListener("click", () => {
        document.documentElement.classList.toggle("light-theme");
        const isLight =
          document.documentElement.classList.contains("light-theme");
        localStorage.setItem("theme", isLight ? "light" : "dark");

        // Redraw dots when theme changes with the correct dot count
        const targetDotCount = Math.round(
          canvas.width * canvas.height * BASE_DENSITY
        );
        const actualDotCount = Math.min(targetDotCount, MAX_DOTS);
        drawSparseDots(actualDotCount);
      });

      // Animation script for the letters - BALANCED APPROACH
      const letters = document.querySelectorAll(".text span");

      // Keep original ranges for reference
      const axes = {
        wght: { min: 350, max: 800 }, // Slightly higher min weight for readability
        wdth: { min: 50, max: 130 },
        opsz: { min: 14, max: 120 },
        GRAD: { min: -100, max: 100 },
        slnt: { min: -5, max: 0 },
        XOPQ: { min: 60, max: 150 }, // Slightly higher min optical weight
        XTRA: { min: 350, max: 550 },
        YOPQ: { min: 35, max: 120 },
        YTAS: { min: 700, max: 850 },
        YTDE: { min: -250, max: -120 },
        YTFI: { min: 600, max: 750 },
        YTLC: { min: 450, max: 550 },
        YTUC: { min: 550, max: 700 },
      };

      // Create balanced relationships between parameters
      const balancedAxes = [
        // When one gets thinner, the other gets thicker (negative correlation)
        { axis1: "wght", axis2: "XOPQ", correlation: -0.6 },
        { axis1: "wdth", axis2: "XOPQ", correlation: -0.4 },
        { axis1: "wght", axis2: "wdth", correlation: -0.3 },
      ];

      const letterStates = Array.from(letters).map(() => ({
        currentValues: Object.fromEntries(
          Object.entries(axes).map(([axis, range]) => [
            axis,
            Math.random() * (range.max - range.min) + range.min,
          ])
        ),
        directions: Object.fromEntries(
          Object.keys(axes).map((axis) => [axis, Math.random() < 0.5 ? -1 : 1])
        ),
        updateCounter: 0,
        // Give each letter a slightly different animation speed
        speed: Math.random() * 0.006 + 0.01, // Increased: Between 0.01 and 0.016
      }));

      // Throttle animation updates to every few frames
      const LETTER_ANIMATION_THROTTLE = 2; // Reduced from 3 to 2 for faster updates
      let frameCount = 0;

      function animate() {
        frameCount++;

        // Only update letters every few frames
        if (frameCount % LETTER_ANIMATION_THROTTLE === 0) {
          letters.forEach((letter, index) => {
            const state = letterStates[index];
            state.updateCounter++;

            // Only check for direction changes occasionally
            if (state.updateCounter % 10 === 0) {
              for (let axis in axes) {
                if (Math.random() < 0.01) {
                  state.directions[axis] *= -1;
                }
              }
            }

            // Primary animation step - move each axis value in its current direction
            for (let axis in axes) {
              state.currentValues[axis] +=
                state.directions[axis] *
                (axes[axis].max - axes[axis].min) *
                state.speed;

              if (state.currentValues[axis] <= axes[axis].min) {
                state.currentValues[axis] = axes[axis].min;
                state.directions[axis] = 1;
              } else if (state.currentValues[axis] >= axes[axis].max) {
                state.currentValues[axis] = axes[axis].max;
                state.directions[axis] = -1;
              }
            }

            // Apply balanced relationships between axes
            balancedAxes.forEach((relation) => {
              const { axis1, axis2, correlation } = relation;

              // Get normalized position of first axis (0 to 1)
              const range1 = axes[axis1].max - axes[axis1].min;
              const normalizedPos1 =
                (state.currentValues[axis1] - axes[axis1].min) / range1;

              // Calculate target position for second axis based on correlation
              // Negative correlation: when one is high, the other should be low
              let targetPos2;
              if (correlation < 0) {
                targetPos2 = 1 - normalizedPos1 * Math.abs(correlation);
              } else {
                targetPos2 = normalizedPos1 * correlation;
              }

              // Calculate a "pull" toward the balanced relationship
              // but don't override the independent animation completely
              const range2 = axes[axis2].max - axes[axis2].min;
              const targetValue2 = axes[axis2].min + targetPos2 * range2;
              const currentValue2 = state.currentValues[axis2];

              // Blend between current value and balanced target (30% influence)
              state.currentValues[axis2] =
                currentValue2 * 0.7 + targetValue2 * 0.3;
            });

            // Extra protection - if stroke weight and width both get low, boost one of them
            const weightNormalized =
              (state.currentValues.wght - axes.wght.min) /
              (axes.wght.max - axes.wght.min);
            const xopqNormalized =
              (state.currentValues.XOPQ - axes.XOPQ.min) /
              (axes.XOPQ.max - axes.XOPQ.min);

            // If both weight and optical weight are in the lower 30%, boost one of them
            if (weightNormalized < 0.3 && xopqNormalized < 0.3) {
              if (Math.random() < 0.5) {
                state.currentValues.wght =
                  axes.wght.min + (axes.wght.max - axes.wght.min) * 0.4;
              } else {
                state.currentValues.XOPQ =
                  axes.XOPQ.min + (axes.XOPQ.max - axes.XOPQ.min) * 0.4;
              }
            }

            // Apply the animation to the letter with rounding for performance
            letter.style.fontVariationSettings = Object.entries(
              state.currentValues
            )
              .map(([axis, value]) => `'${axis}' ${Math.round(value)}`)
              .join(", ");
          });
        }

        requestAnimationFrame(animate);
      }

      animate();

      // Email protection script with toast notification instead of alert
      document
        .getElementById("email-link")
        .addEventListener("click", function (e) {
          e.preventDefault();
          const user = "contact";
          const domain = "neomania.net";
          const emailAddress = user + "@" + domain;

          const textarea = document.createElement("textarea");
          textarea.value = emailAddress;
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand("copy");
          document.body.removeChild(textarea);

          const toast = document.getElementById("toast");
          toast.classList.add("show");

          setTimeout(function () {
            toast.classList.remove("show");
          }, 3000);
        });

      // Noise Canvas Implementation - DENSITY-CONSISTENT
      const canvas = document.getElementById("noise-canvas");
      const ctx = canvas.getContext("2d");

      let animationId = null;
      const animationInterval = 300; // Animation interval in milliseconds

      // Reference density calibrated for iPhone-sized screens
      const BASE_DENSITY = 0.05; // dots per pixel
      const BASE_WIDTH = 375; // iPhone reference width in pixels
      const BASE_HEIGHT = 812; // iPhone reference height in pixels
      const BASE_DOT_COUNT = Math.round(
        BASE_WIDTH * BASE_HEIGHT * BASE_DENSITY
      );

      // Maximum number of dots to render for performance
      const MAX_DOTS = 25000;

      // Canvas scaling for large screens
      const MAX_CANVAS_DIMENSION = 1500; // Cap internal canvas size for performance
      let scaleRatio = 1; // Scale ratio for drawing the canvas to screen

      function resizeCanvas() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        // Determine if we need to scale down the canvas for large screens
        if (
          screenWidth > MAX_CANVAS_DIMENSION ||
          screenHeight > MAX_CANVAS_DIMENSION
        ) {
          scaleRatio = Math.max(
            screenWidth / MAX_CANVAS_DIMENSION,
            screenHeight / MAX_CANVAS_DIMENSION
          );

          canvas.width = Math.ceil(screenWidth / scaleRatio);
          canvas.height = Math.ceil(screenHeight / scaleRatio);

          // Apply CSS scaling for display
          canvas.style.transform = `scale(${scaleRatio})`;
          canvas.style.transformOrigin = "0 0";
        } else {
          // Reset for normal sizes
          scaleRatio = 1;
          canvas.width = screenWidth;
          canvas.height = screenHeight;
          canvas.style.transform = "none";
        }

        // Calculate dot count based on screen size, but cap it for performance
        const targetDotCount = Math.round(
          canvas.width * canvas.height * BASE_DENSITY
        );
        const actualDotCount = Math.min(targetDotCount, MAX_DOTS);

        console.log(
          `Canvas: ${canvas.width}x${
            canvas.height
          }, Scale: ${scaleRatio.toFixed(2)}, Dots: ${actualDotCount}`
        );

        drawSparseDots(actualDotCount);
      }

      function drawSparseDots(dotCount) {
        const isDarkMode =
          !document.documentElement.classList.contains("light-theme");

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Dot size might be bigger on scaled canvas for consistent visual size
        const dotSize = Math.max(1, Math.round(scaleRatio / 2));

        for (let i = 0; i < dotCount; i++) {
          const x = Math.floor(Math.random() * canvas.width);
          const y = Math.floor(Math.random() * canvas.height);

          // Set different brightness based on theme
          let brightness;
          if (isDarkMode) {
            brightness = Math.floor(Math.random() * 180) + 75; // Brighter in dark mode (75-255)
          } else {
            brightness = Math.floor(Math.random() * 40); // Darker in light mode (0-40)
          }

          // Higher opacity for better visibility
          const opacity = Math.random() * 0.7 + 0.3; // 0.3-1.0 opacity

          // Draw the pixel with potentially scaled size
          ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, ${opacity})`;
          ctx.fillRect(x, y, dotSize, dotSize);
        }
      }

      function startAnimation() {
        stopAnimation();

        // Calculate dot count on startup
        const targetDotCount = Math.round(
          canvas.width * canvas.height * BASE_DENSITY
        );
        const actualDotCount = Math.min(targetDotCount, MAX_DOTS);

        if (isReducedMotion) {
          drawSparseDots(actualDotCount);
        } else {
          drawSparseDots(actualDotCount);
          animationId = setInterval(
            () => drawSparseDots(actualDotCount),
            animationInterval
          );
        }
      }

      function stopAnimation() {
        if (animationId) {
          clearInterval(animationId);
          animationId = null;
        }
      }

      // Listen for reduced motion preference changes
      window
        .matchMedia("(prefers-reduced-motion: reduce)")
        .addEventListener("change", (e) => {
          isReducedMotion = e.matches;
          document.documentElement.setAttribute(
            "data-motion",
            isReducedMotion ? "reduced" : "normal"
          );
          startAnimation();
        });

      // Throttle the resize event
      let resizeTimeout;
      window.addEventListener("resize", () => {
        if (resizeTimeout) clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resizeCanvas, 100);
      });

      resizeCanvas();
      startAnimation();
    </script>
  </body>
</html>
